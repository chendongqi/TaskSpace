# 季度目标管理功能设计文档

## Context
项目已有年度目标管理功能，用户希望能够将年度目标拆解为更细致的季度目标，并通过季度目标的进度自动计算年度目标的进度。这需要建立年度目标和季度目标之间的关联关系，实现加权进度计算机制。

### 背景
- 已实现年度目标功能（`goal-management` 规范）
- 数据存储使用 `DataStorage` 类（LocalStorage + 服务器备份）
- UI 采用抽屉式模态框，使用 shadcn/ui 和 Framer Motion
- 主应用使用 React Hooks 进行状态管理

### 约束
- 必须向后兼容现有年度目标数据
- 季度目标和年度目标的 UI 必须独立但风格一致
- 自动进度计算必须实时更新
- 权重机制必须灵活且易于理解

### 利益相关者
- 用户：需要更细粒度的目标管理和自动进度追踪
- 开发者：需要清晰的数据关联模型和计算逻辑

## Goals / Non-Goals

### Goals
1. **实现季度目标独立管理**：季度目标有自己的 UI、筛选和 CRUD 操作
2. **建立层级关联**：季度目标可以关联到年度目标，并设定权重
3. **自动进度计算**：年度目标进度根据关联的季度目标自动计算
4. **灵活的权重机制**：支持任意权重分配，系统自动归一化
5. **向后兼容**：不影响现有年度目标的使用方式

### Non-Goals
1. **多层嵌套**：不支持季度目标再拆解为更小的目标
2. **跨年关联**：季度目标只能关联同年的年度目标
3. **自动拆解**：不自动将年度目标拆解为季度目标
4. **月度目标**：暂不支持月度级别的目标管理

## Decisions

### Decision 1: 数据模型设计

**决策**：季度目标和年度目标使用独立的数据数组，通过 `yearlyGoalId` 字段建立关联。

**理由**：
- **独立存储**：便于独立查询、筛选和管理
- **弱耦合**：删除年度目标不会级联删除季度目标（用户可能想保留季度目标）
- **灵活性**：季度目标可以独立存在，不必强制关联年度目标

**替代方案**：
1. **嵌套结构**（年度目标包含季度目标数组）
   - 优点：数据关联直观
   - 缺点：查询季度目标需要遍历年度目标；数据备份和恢复复杂；限制了季度目标的独立性
2. **关系数据库**
   - 优点：强大的关联查询能力
   - 缺点：与当前 LocalStorage 架构不兼容；增加部署复杂度

**选择独立数组的原因**：
- 符合现有架构（习惯、任务、标签都是独立数组）
- 便于数据迁移和备份
- 支持季度目标独立使用场景

### Decision 2: 进度计算机制

**决策**：使用加权平均算法，公式为 `年度进度 = Σ(季度目标进度 × 权重) / Σ(权重)`，权重总和自动归一化。

**理由**：
- **灵活性**：用户可以根据重要性分配任意权重
- **容错性**：自动归一化避免权重总和不为 100% 的错误
- **实时性**：季度目标变化立即反映到年度目标

**权重归一化**：
```javascript
// 示例：3 个季度目标，权重分别为 30, 40, 50（总和 120）
// 归一化后：25%, 33.33%, 41.67%
const normalizedWeights = weights.map(w => (w / totalWeight) * 100);
const yearlyProgress = quarterlyGoals.reduce((sum, goal, index) => {
  return sum + (goal.progress * normalizedWeights[index]);
}, 0) / 100;
```

**替代方案**：
1. **强制权重总和为 100%**
   - 优点：数学上直观
   - 缺点：用户体验差，每次调整权重都要确保总和为 100%
2. **平均值**（忽略权重）
   - 优点：简单
   - 缺点：无法体现季度目标的重要性差异
3. **手动计算**
   - 优点：用户完全控制
   - 缺点：失去自动化的意义

**选择加权平均 + 归一化的原因**：
- 平衡了灵活性和易用性
- 符合用户心智模型（重要的目标权重更高）
- 自动归一化减少用户负担

### Decision 3: 自动计算与手动模式的切换

**决策**：年度目标根据是否有关联季度目标自动切换模式：
- **无关联**：手动模式，用户可编辑进度，`autoCalculated = false`
- **有关联**：自动模式，进度由系统计算，禁用手动编辑，`autoCalculated = true`

**理由**：
- **一致性**：避免手动进度和自动计算进度冲突
- **透明性**：用户清楚知道进度来源
- **灵活性**：支持两种使用场景（独立年度目标 vs 拆解型年度目标）

**触发条件**：
- 添加第一个关联季度目标 → 切换到自动模式
- 删除最后一个关联季度目标 → 切换到手动模式
- 解除所有季度目标关联 → 切换到手动模式

**UI 提示**：
- 自动模式：显示"进度由 X 个季度目标自动计算"，进度条禁用
- 手动模式：显示进度滑块，允许编辑

**替代方案**：
1. **始终允许手动编辑**
   - 优点：用户完全控制
   - 缺点：手动值会被自动计算覆盖，造成困惑
2. **始终自动计算**
   - 优点：简单
   - 缺点：强制所有年度目标必须有季度目标
3. **用户手动切换模式**
   - 优点：最大灵活性
   - 缺点：增加 UI 复杂度，用户可能不理解何时切换

**选择自动切换的原因**：
- 符合用户期望（有季度目标就自动计算）
- 避免数据不一致
- UI 简洁，无需额外开关

### Decision 4: 季度目标删除或解除关联时的处理

**决策**：删除季度目标或解除关联后，立即重新计算年度目标进度。如果所有季度目标都被删除/解除，年度目标切换到手动模式，进度保持最后计算值。

**理由**：
- **数据一致性**：确保年度目标进度始终反映当前季度目标状态
- **用户友好**：保留最后计算的进度值，避免进度突然归零

**行为**：
```javascript
// 删除季度目标后
1. 从 quarterlyGoals 数组中移除
2. 查找关联的年度目标
3. 重新计算该年度目标进度
4. 如果没有剩余关联季度目标，设置 autoCalculated = false
5. 保存更新后的年度目标
```

**替代方案**：
1. **进度归零**
   - 优点：明确表示没有关联
   - 缺点：丢失进度信息，用户可能不满
2. **保持原进度，但标记为"过期"**
   - 优点：保留历史信息
   - 缺点：增加数据复杂度
3. **阻止删除**（如果有关联）
   - 优点：避免意外删除
   - 缺点：限制用户操作灵活性

**选择重新计算 + 保留最后值的原因**：
- 数据一致性优先
- 保留有用的进度信息
- 用户可以随时手动调整（切换到手动模式后）

### Decision 5: UI 组件设计

**决策**：季度目标使用独立的 `QuarterlyGoalsTracker` 组件，与 `YearlyGoalsTracker` 并列，通过不同的快捷键和导航入口打开。

**理由**：
- **独立性**：季度目标和年度目标有不同的筛选维度（年份+季度 vs 年份）
- **复用性**：可以复用年度目标的布局和样式代码
- **性能**：避免单一组件过于复杂

**组件间通信**：
- 通过 `app/page.js` 的状态和回调函数传递数据
- 季度目标变化触发年度目标更新通过回调函数实现

**导航入口**：
- 主界面添加"季度目标" (Quarterly Goals) 按钮
- 快捷键：`Ctrl/Cmd + Q`
- 年度目标卡片上可点击"查看关联季度目标"跳转

**替代方案**：
1. **单一组件，标签页切换**
   - 优点：一体化体验
   - 缺点：组件复杂度高，筛选逻辑混乱
2. **嵌套显示**（年度目标内嵌季度目标）
   - 优点：层级关系直观
   - 缺点：不支持独立的季度目标，UI 过于复杂

**选择独立组件的原因**：
- 符合现有架构模式
- 代码清晰，易于维护
- 支持独立季度目标场景

### Decision 6: 跨年关联限制

**决策**：季度目标只能关联同年的年度目标，UI 中只显示同年份的年度目标供选择。

**理由**：
- **语义一致性**：季度目标属于某一年的某个季度，关联其他年份的年度目标没有意义
- **简化逻辑**：避免跨年数据关联带来的复杂性
- **用户理解**：符合用户的直觉认知

**实现**：
```javascript
// 在创建/编辑季度目标时，筛选年度目标
const availableYearlyGoals = yearlyGoals.filter(
  goal => goal.year === quarterlyGoal.year
);
```

**替代方案**：
1. **允许跨年关联**
   - 优点：最大灵活性
   - 缺点：语义混乱，难以理解
2. **自动创建对应年份的年度目标**
   - 优点：便捷
   - 缺点：可能创建用户不需要的目标

**选择同年限制的原因**：
- 语义清晰
- 实现简单
- 符合目标管理的常见做法

## Risks / Trade-offs

### Risk 1: 权重总和为零
**风险**：用户为所有关联季度目标设置权重为 0，导致除零错误。

**缓解**：
- 检测权重总和是否为 0
- 如果为 0，回退到平均值算法（所有季度目标权重相等）
- UI 提示用户至少为一个季度目标设置权重

### Risk 2: 删除年度目标后关联的季度目标成为"孤儿"
**风险**：用户删除年度目标，但关联的季度目标仍然引用该年度目标 ID。

**缓解**：
- 删除年度目标时，不级联删除季度目标（用户可能想保留）
- 季度目标显示时检查关联的年度目标是否存在
- 如果不存在，显示"关联的年度目标已删除"，允许用户重新关联或解除关联

### Risk 3: 数据同步冲突
**风险**：用户在不同设备上同时修改季度目标和年度目标，导致进度不一致。

**缓解**：
- 依赖现有的 `DataStorage` 智能合并机制
- 合并时重新计算所有年度目标进度
- 以服务器数据为准，本地数据在恢复后重新计算

### Risk 4: 性能问题（大量目标时）
**风险**：用户创建大量季度目标，每次变更都触发年度目标进度计算，可能影响性能。

**缓解**：
- 进度计算逻辑优化（O(n) 复杂度）
- 仅计算受影响的年度目标，不全量计算
- 防抖机制（现有 DataStorage 已有 1 秒防抖）

**性能估算**：
- 假设用户有 10 个年度目标，每个关联 4 个季度目标
- 总共 40 个季度目标
- 每次更新只计算 1 个年度目标（4 个季度目标的加权平均）
- 时间复杂度：O(4) ≈ 常数时间
- 可接受的性能开销

## Migration Plan

### 数据迁移
1. **新用户**：直接使用新数据结构
2. **现有用户**：
   - `quarterlyGoals` 初始化为空数组
   - 现有年度目标保持手动模式（`autoCalculated = false`）
   - 向后兼容，无需数据迁移脚本

### 代码迁移
1. 添加 `quarterlyGoals` 到 LocalStorage keys
2. 在 `storage.js` 中添加合并逻辑
3. 在 `page.js` 中添加状态和函数
4. 创建新组件 `quarterly-goals-tracker.js`
5. 修改 `yearly-goals-tracker.js` 添加关联信息显示

### 部署步骤
1. 部署后端（如果有 API 变更）
2. 部署前端（包含新组件和逻辑）
3. 监控错误日志
4. 验证数据备份和恢复

### 回滚计划
- 如果出现严重问题，回滚代码版本
- 用户数据不受影响（季度目标数据独立存储）
- 年度目标回到手动模式

## Open Questions

1. **是否需要批量操作**：如"批量将年度目标拆解为 4 个季度目标"？
   - 答：暂不需要，用户可以手动创建

2. **是否显示历史季度目标**：如 2024 Q1 的目标在 Q2 时是否仍然显示？
   - 答：显示所有季度目标，用户可以通过筛选查看特定季度

3. **是否支持季度目标关联多个年度目标**：一个季度目标同时贡献给多个年度目标？
   - 答：暂不支持，保持简单的一对多关系（一个年度目标对多个季度目标）

4. **权重的 UI 交互**：使用滑块、输入框，还是百分比选择器？
   - 答：使用数字输入框（0-100），简单直接

5. **年度目标进度更新的通知**：是否需要提示用户"年度目标进度已更新"？
   - 答：不需要，进度实时更新，避免打扰用户


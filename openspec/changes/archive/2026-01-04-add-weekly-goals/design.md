# 周目标管理功能设计文档

## Context
项目已有年度目标和季度目标管理功能，用户希望能够将季度目标拆解为更细致的周目标，并通过周目标的进度自动计算季度目标的进度。这需要建立季度目标和周目标之间的关联关系，实现加权进度计算机制，并确保级联更新到年度目标。

### 背景
- 已实现年度目标功能（`goal-management` 规范）
- 已实现季度目标功能（拆解自年度目标）
- 数据存储使用 `DataStorage` 类（LocalStorage + 服务器备份）
- UI 采用抽屉式模态框，使用 shadcn/ui 和 Framer Motion
- 主应用使用 React Hooks 进行状态管理

### 约束
- 必须向后兼容现有季度目标和年度目标数据
- 周目标和季度目标的 UI 必须独立但风格一致
- 自动进度计算必须实时更新，并级联到年度目标
- 权重机制必须灵活且易于理解
- 周数计算需要处理跨年、跨季度的情况

### 利益相关者
- 用户：需要更细粒度的目标管理和自动进度追踪
- 开发者：需要清晰的数据关联模型和计算逻辑

## Goals / Non-Goals

### Goals
1. **实现周目标独立管理**：周目标有自己的 UI、筛选和 CRUD 操作
2. **建立层级关联**：周目标可以关联到季度目标，并设定权重
3. **自动进度计算**：季度目标进度根据关联的周目标自动计算
4. **级联更新**：周目标变化时，自动更新季度目标进度，进而更新年度目标进度
5. **灵活的权重机制**：支持任意权重分配，系统自动归一化
6. **向后兼容**：不影响现有季度目标和年度目标的使用方式

### Non-Goals
1. **多层嵌套**：不支持周目标再拆解为更小的目标
2. **跨季度关联**：周目标只能关联同季度内的季度目标
3. **自动拆解**：不自动将季度目标拆解为周目标
4. **日目标**：暂不支持日级别的目标管理

## Decisions

### Decision 1: 数据模型设计

**决策**：周目标和季度目标使用独立的数据数组，通过 `quarterlyGoalId` 字段建立关联。

**理由**：
- **独立存储**：便于独立查询、筛选和管理
- **弱耦合**：删除季度目标不会级联删除周目标（用户可能想保留周目标）
- **灵活性**：周目标可以独立存在，不必强制关联季度目标
- **一致性**：与季度目标和年度目标的关系保持一致

**数据结构**：
```javascript
{
  id: string,              // 唯一标识符
  title: string,           // 目标标题
  description: string,     // 目标描述
  year: number,            // 目标年份
  quarter: number,         // 目标季度 (1-4)
  week: number,            // 目标周数 (1-52，或季度内周数 1-13)
  completed: boolean,      // 完成状态
  progress: number,        // 完成进度 (0-100)
  quarterlyGoalId: string, // 关联的季度目标 ID（可选）
  weight: number,          // 权重占比 (0-100，仅当关联季度目标时有效)
  tag: string,             // 标签 ID（可选）
  createdAt: Date          // 创建时间
}
```

### Decision 2: 周数表示方式

**决策**：使用全局周数（1-52）和季度内周数（1-13）两种表示方式，UI 中显示季度内周数，存储时使用全局周数。

**理由**：
- **全局周数**：便于跨季度查询和筛选
- **季度内周数**：更符合用户心智模型（"Q1 第 3 周"）
- **计算方式**：使用 ISO 周数标准，确保跨年、跨季度的一致性

**周数计算**：
```javascript
// 获取指定日期所在年份的周数（ISO 8601 标准）
function getWeekNumber(date) {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  const dayNum = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
}

// 获取季度内周数
function getQuarterWeekNumber(year, quarter, week) {
  const quarterStartWeek = (quarter - 1) * 13 + 1;
  return week - quarterStartWeek + 1;
}
```

**替代方案**：
1. **仅使用季度内周数**
   - 优点：简单直观
   - 缺点：跨季度查询困难，需要额外计算
2. **仅使用全局周数**
   - 优点：统一标准
   - 缺点：用户理解困难（"第 15 周"不如"Q1 第 3 周"直观）

**选择混合方式的原因**：
- 平衡了技术实现和用户体验
- 存储使用全局周数便于查询
- UI 显示季度内周数更直观

### Decision 3: 进度计算机制

**决策**：使用加权平均算法，公式为 `季度进度 = Σ(周目标进度 × 权重) / Σ(权重)`，权重总和自动归一化。季度目标进度更新后，自动触发年度目标进度重新计算。

**理由**：
- **一致性**：与季度目标到年度目标的计算逻辑保持一致
- **灵活性**：用户可以根据重要性分配任意权重
- **容错性**：自动归一化避免权重总和不为 100% 的错误
- **实时性**：周目标变化立即反映到季度目标和年度目标

**级联更新流程**：
```javascript
// 周目标更新 → 季度目标更新 → 年度目标更新
1. 周目标进度变化
2. 计算关联的季度目标进度（加权平均）
3. 更新季度目标进度和 autoCalculated 标志
4. 如果季度目标关联了年度目标，重新计算年度目标进度
5. 更新年度目标进度和 autoCalculated 标志
```

### Decision 4: 自动计算与手动模式的切换

**决策**：季度目标根据是否有关联周目标自动切换模式：
- **无关联**：手动模式，用户可编辑进度，`autoCalculated = false`
- **有关联**：自动模式，进度由系统计算，禁用手动编辑，`autoCalculated = true`

**理由**：
- **一致性**：与年度目标和季度目标的关系保持一致
- **透明性**：用户清楚知道进度来源
- **灵活性**：支持两种使用场景（独立季度目标 vs 拆解型季度目标）

**触发条件**：
- 添加第一个关联周目标 → 切换到自动模式
- 删除最后一个关联周目标 → 切换到手动模式
- 解除所有周目标关联 → 切换到手动模式

### Decision 5: UI 组件设计

**决策**：周目标使用独立的 `WeeklyGoalsTracker` 组件，与 `QuarterlyGoalsTracker` 并列，通过不同的快捷键和导航入口打开。

**理由**：
- **独立性**：周目标和季度目标有不同的筛选维度（年份+季度+周 vs 年份+季度）
- **复用性**：可以复用季度目标的布局和样式代码
- **性能**：避免单一组件过于复杂

**导航入口**：
- 主界面添加"周目标" (Weekly Goals) 按钮
- 快捷键：`Ctrl/Cmd + W`
- 季度目标卡片上可点击"查看关联周目标"跳转

**筛选维度**：
- 年份选择器
- 季度选择器（Q1-Q4）
- 周数选择器（显示当前季度内的周数，如"第 1 周"到"第 13 周"）

### Decision 6: 跨季度关联限制

**决策**：周目标只能关联同季度内的季度目标，UI 中只显示同年份同季度的季度目标供选择。

**理由**：
- **语义一致性**：周目标属于某一季度的某一周，关联其他季度的季度目标没有意义
- **简化逻辑**：避免跨季度数据关联带来的复杂性
- **用户理解**：符合用户的直觉认知

**实现**：
```javascript
// 在创建/编辑周目标时，筛选季度目标
const availableQuarterlyGoals = quarterlyGoals.filter(
  goal => goal.year === weeklyGoal.year && goal.quarter === weeklyGoal.quarter
);
```

## Risks / Trade-offs

### Risk 1: 周数计算复杂性
**风险**：不同年份的周数计算可能不一致，跨年、跨季度边界处理复杂。

**缓解**：
- 使用 ISO 8601 周数标准
- 提供周数计算工具函数
- 在 UI 中显示季度内周数，降低用户理解成本

### Risk 2: 级联更新性能
**风险**：周目标更新可能触发季度目标和年度目标的级联更新，大量数据时可能影响性能。

**缓解**：
- 仅计算受影响的季度目标和年度目标，不全量计算
- 使用防抖机制（现有 DataStorage 已有 1 秒防抖）
- 进度计算逻辑优化（O(n) 复杂度）

**性能估算**：
- 假设用户有 10 个年度目标，每个关联 4 个季度目标，每个季度目标关联 13 个周目标
- 总共 520 个周目标
- 每次更新只计算 1 个季度目标（13 个周目标的加权平均）和 1 个年度目标（4 个季度目标的加权平均）
- 时间复杂度：O(13) + O(4) ≈ 常数时间
- 可接受的性能开销

### Risk 3: 权重总和为零
**风险**：用户为所有关联周目标设置权重为 0，导致除零错误。

**缓解**：
- 检测权重总和是否为 0
- 如果为 0，回退到平均值算法（所有周目标权重相等）
- UI 提示用户至少为一个周目标设置权重

### Risk 4: 删除季度目标后关联的周目标成为"孤儿"
**风险**：用户删除季度目标，但关联的周目标仍然引用该季度目标 ID。

**缓解**：
- 删除季度目标时，不级联删除周目标（用户可能想保留）
- 周目标显示时检查关联的季度目标是否存在
- 如果不存在，显示"关联的季度目标已删除"，允许用户重新关联或解除关联

## Migration Plan

### 数据迁移
1. **新用户**：直接使用新数据结构
2. **现有用户**：
   - `weeklyGoals` 初始化为空数组
   - 现有季度目标保持手动模式（`autoCalculated = false`）
   - 向后兼容，无需数据迁移脚本

### 代码迁移
1. 添加 `weeklyGoals` 到 LocalStorage keys
2. 在 `storage.js` 中添加合并逻辑
3. 在 `page.js` 中添加状态和函数
4. 创建新组件 `weekly-goals-tracker.js`
5. 修改 `quarterly-goals-tracker.js` 添加关联信息显示

### 部署步骤
1. 部署后端（如果有 API 变更）
2. 部署前端（包含新组件和逻辑）
3. 监控错误日志
4. 验证数据备份和恢复

### 回滚计划
- 如果出现严重问题，回滚代码版本
- 用户数据不受影响（周目标数据独立存储）
- 季度目标回到手动模式

## Open Questions

1. **是否需要批量操作**：如"批量将季度目标拆解为 13 个周目标"？
   - 答：暂不需要，用户可以手动创建

2. **是否显示历史周目标**：如 2024 Q1 第 1 周的目标在 Q2 时是否仍然显示？
   - 答：显示所有周目标，用户可以通过筛选查看特定周

3. **是否支持周目标关联多个季度目标**：一个周目标同时贡献给多个季度目标？
   - 答：暂不支持，保持简单的一对多关系（一个季度目标对多个周目标）

4. **权重的 UI 交互**：使用滑块、输入框，还是百分比选择器？
   - 答：使用数字输入框（0-100），简单直接

5. **季度目标进度更新的通知**：是否需要提示用户"季度目标进度已更新"？
   - 答：不需要，进度实时更新，避免打扰用户

6. **周数显示格式**：显示为"Q1 第 3 周"还是"2024 年第 15 周"？
   - 答：优先显示"Q1 第 3 周"（季度内周数），更直观

